import numpy as np
from scipy.sparse import csr_matrix
from itertools import product
import functools
import operator




def all_possible_substrings(k):
    """
    With a k spectrum kernel, let us find all the possible combinations of chars of size k in the sequence x
    This way, we could index them in the sequence x
    """
    char_list = list(['A', 'C','G','T'])
    alphabet_tuples = list(product(char_list,repeat=k))
    alphabet = dict()
    idx=0
    for i in alphabet_tuples:
        alphabet[functools.reduce(operator.add, (i))] = idx
        idx += 1
        #alphabet.append(functools.reduce(operator.add, (i)))
    return alphabet

def pre_indexing(X, k, alphabet=None):
    """
    Outputs a sparse matrix of shape Transforms an input array into a sparse matrix encoding the number of occurences 
    of each letter of the alphabet composed of substrings of size k
    """
    i = 0
    n = X.shape[0]
    if alphabet is None:
        alphabet = all_possible_substrings(k)
    D = np.zeros((n,len(alphabet)))
    
    for i in range(X.shape[0]):
        idx=0
        while idx + k < len(X[i]):
            D[i, alphabet[X[i][idx:idx+k]]] += 1
            idx += 1
    D = csr_matrix(D, dtype = int)
    return D

def spectrum_kernel(X_train, X_val, X_test, k, alphabet=None):
    # Kill two birds with one stone and compute K_train, K_val and K_test all at once.
    """
    Computes the spectrum kernels for X_train (n_train x n_train), X_validation and X_test
    (on the RKHS generated by X_train's samples) which is of shape n_validation x n_train (resp n_test x n_train)
    """
    if alphabet is None:
        #D_train = pre_indexing(X_train,k).toarray()
        #D_val = pre_indexing(X_val,k).toarray()
        alphabet = all_possible_substrings(k)
   
    D_train = pre_indexing(X_train,k,alphabet)
    D_val = pre_indexing(X_val,k,alphabet)
    D_test = pre_indexing(X_test,k,alphabet)
        
        
    #K_val = np.inner(D_val, D_train)
    #K_val = K_val.astype('float')
    
    K_train = D_train.dot(D_train.transpose())
    K_train = K_train.toarray().astype('float')
    
    K_val = D_val.dot(D_train.transpose())
    K_val = K_val.toarray().astype('float')
    
    K_test = D_test.dot(D_train.transpose())
    K_test = K_test.toarray().astype('float')
    
        
    return(K_train, K_val, K_test)

##### Fonctions to find a substring neighbor's

def neighbors(word, m):
    """
    This gives neighbors that differ in exactly m places
    """
    
    char_list = list(['A', 'C','G','T'])
    assert(m <= len(word))

    if m == 0:
        return [word]

    r2 = neighbors(word[1:], m-1)
    r = [c + r3 for r3 in r2 for c in char_list if c != word[0]]

    if (m < len(word)):
        r2 = neighbors(word[1:], m)
        r += [word[0] + r3 for r3 in r2]

    return r

def neighbors2(pattern, m):
    """
    This gives neighbors that differ in at most m places.
    """
    return sum([neighbors(pattern, d2) for d2 in range(m + 1)], [])

def all_possible_substrings_mismatch2(k,m):
    """
    With a k spectrum kernel, let us find all the possible combinations of chars of size k in the sequence x
    This way, we could index them in the sequence x
    """
    
    alphabet = all_possible_substrings(k)
    alphabet_mismatch = dict()
    
    for key, value in alphabet.items():
        neighbors_key = neighbors2(key, m)
        # eah key in the dictionary receives as value a list of its own
        # and its neighbors indexes on the matrix D.
        alphabet_mismatch[key] = [alphabet[neigh] for neigh in neighbors_key]
   
    return alphabet_mismatch

def pre_indexing_mismatch2(X, k, m, alphabet=None):
    """
    Transforms an input array into a sparse matrix encoding the number of occurences of each letter of
    the alphabet composed of substrings of size k
    """
    n = X.shape[0]
    
    if alphabet is None:
        alphabet = all_possible_substrings_mismatch2(k,m)
    
    D = np.zeros((n,len(alphabet)))
    
    for i in range(X.shape[0]):
        idx=0
        while idx + k < len(X[i]):
            D[i, alphabet[X[i][idx:idx+k]]] += 1
            idx += 1
    D = csr_matrix(D, dtype = int)
    return D

def mismatch_spectrum_kernel2(X_train, X_val, X_test, k, m=1, alphabet =None):
    """
    Computes the spectrum kernels for X_train (n_train x n_train) and X_validation (on the RKHS generated(?) by
    X_train's samples) which is of shape n_validation x n_train
    "test" mode only gives as output the testing kernel
    """
    if alphabet is None:
        alphabet = all_possible_substrings_mismatch(k,m)
    
    D_train = pre_indexing_mismatch2(X_train, k, m, alphabet)
    D_val = pre_indexing_mismatch2(X_val, k, m, alphabet)
    D_test = pre_indexing_mismatch2(X_test, k, m, alphabet)
    
    K_train = D_train.dot(D_train.transpose())
    K_train = K_train.toarray().astype('float')
    
    K_val = D_val.dot(D_train.transpose())
    K_val = K_val.toarray().astype('float')
    
    K_test = D_test.dot(D_train.transpose())
    K_test = K_test.toarray().astype('float')
    
        
    return(K_train, K_val, K_test)
